<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[爬虫的学习]]></title>
    <url>%2F2019%2F05%2F08%2F%E7%88%AC%E8%99%AB%E7%9A%84%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[直接开始吧首先 这是zzz贴出来的爬虫模板,(手动滑稽). 可以借鉴一下. 简单说一下，爬虫基本都是分为四步 请求 解析 匹配 23可合并 保存内容 bs4的学习 然后我比较喜欢beautiful soup这个模块 贴一段代码 大家看看吧 都有注释 bs4的官网讲的也很详细 12345678910111213141516171819202122232425262728293031323334353637383940414243444546from bs4 import BeautifulSoupimport lxml#1.转类型html_doc = """&lt;html&gt;&lt;head&gt;&lt;title id ="one"&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p class="title"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;&lt;p class="story"&gt;Once upon a time there were three little sisters; and their names were&lt;a href="http://example.com/elsie" class="sister" id="link1"&gt;Elsie&lt;/a&gt;,&lt;a href="http://example.com/lacie" class="sister" id="link2"&gt;Lacie&lt;/a&gt; and&lt;a href="http://example.com/tillie" class="sister" id="link3"&gt;Tillie&lt;/a&gt;;and they lived at the bottom of a well.&lt;/p&gt;&lt;p class="story"&gt;...&lt;/p&gt;"""#1.转类型 bs4.Bautifulsoupsoup = BeautifulSoup(html_doc,'lxml')#2通用解析方法#find--返回符合查询条件的第一个标签result = soup.find(name="p")#p标签result = soup.find(attrs=&#123;"class":"title"&#125;)#类名result = soup.find(text="Tillie")#find_all(返回标签对象)result =soup.find_all('a')result = soup.find_all('a', limit=1)result = soup.find_all(attrs=&#123;"class":"sister"&#125;)#select_one--css选择器result = soup.select_one('.sister')#select--css选择器result =soup.select('.sister')result = soup.select("#one")result = soup.select('head title')#head标签下的后代title标签result = soup.select('title,.title')#title标签或者title类同时取出result = soup.select('a[id="link3"]')#标签包裹的内容--listresult = soup.select('.title')[0].string#标签的属性#result = soup.select('#link3')[0].get('href')print(result) 乞丐版试试爬斗图网，可以拿去和别人斗图啦 哈哈哈 所用第三方模块 1.requests 2.bs4 3.lxml 不多说，代码加直接注释。 12345678910111213141516171819202122232425262728293031323334import requestsfrom bs4 import BeautifulSoup# bs4 是真好用啊 真香 哈哈哈from lxml import etreeurl = "http://www.bbsnet.com/tag/qq/page/"def run(geturl): for x in range(1, 27): urls = geturl+str(x) #将每一个page参数加上 result = requests.get(url=urls).content #获取请求的内容 soup = BeautifulSoup(result, 'lxml') #将获取的内容转换为soup的对象 result = soup.select('.zoom img') #通过bs4自带的css选择方法 找到img标签 for i in result: # 讲得到的那一页的img标签循环 print(i['src']) #获得打印图片的src x = i['src'] #将src赋给x image_name = x[-7:] #给image取个名字 之后要用 print(image_name) try: image = requests.get(x).content #通过url获取image的内容 注意是binary 二进制 #print(image) with open('%s'%image_name, 'wb') as f: #开始写入文件 文件名就是刚刚那个 f.write(image) print('ok\n') #写入成功 打印ok 换行 except: #出了意外就下一个 continueif __name__ == '__main__': run(geturl=url) 效果图： 进阶版所用第三方模块 1.requests 2.bs4 3.lxml 4.selenium 比起刚刚那个加入一个selenium模块，可以去驱动浏览器，至于用这个东西驱动浏览器还需要一些其他的操作，百度一下吧，有很多的。 这次爬笔趣阁，看小说的。。。 123456789101112131415161718192021222324252627import requestsfrom bs4 import BeautifulSoupfrom lxml import etreefrom selenium import webdriverurl = 'http://www.xbiquge.la/10/10512/'def run(): for i in range(4541611, 17384875): try: browser = webdriver.Chrome() #初始化对象 浏览器是chrome browser.get(url+str(i)+'.html') #请求页面 soup = BeautifulSoup(browser.page_source,'lxml') #转换为soup对象 print(soup) #打印一下内容 result = soup.select('div[id="content"]') #筛选一下内容 print(str(result).replace('&lt;br/&gt;', '')) #因为有换行符 用字符串的replace方法去掉 with open(str(i)+'.txt', 'w', encoding='utf-8')as f: f.write(str(result).replace('&lt;br/&gt;', '')) #存入 except: continue finally: browser.close() #关闭浏览器if __name__ == '__main__': run() 效果图：]]></content>
  </entry>
  <entry>
    <title><![CDATA[ssh协议登陆Linux远程桌面]]></title>
    <url>%2F2019%2F04%2F29%2Fssh%E5%8D%8F%E8%AE%AE%E7%99%BB%E9%99%86Linux%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[开头ssh(secure shell)是用于远程登陆和信息交换的一种协议，除了ssh之外还有telent协议和http协议之类的，但是综合安全和传输速度方面来说，ssh更好，而之前买了腾讯云的服务器，一直在电脑上操作，突然想也可以在手机上操作，因此有了这篇博客，同时也是学习了一波到底ssh登陆的到底是怎样过程。 附上大佬文章 ssh登陆过程ssh登陆比较其他登陆方式更安全，是因为采用非对称加密算法，生成公钥和私钥两种密钥，比不使用加密和对称加密更安全，很难通过公钥解密出私钥。但有可能会产生中间人攻击，黑客冒充服务器截获请求，用户如果不比对公钥是否正确，就连接，因为连接需要输入登陆密码，对于用户来说认为这是正常的服务器，就输出了自己的服务器密码，那黑客就得到了你的密码。 具体登陆过程是这样的： （1）远程主机收到用户的登录请求，把自己的公钥发给用户。（2）用户使用这个公钥，将登录密码加密后，发送回来。（3）远程主机用自己的私钥，解密登录密码，如果密码正确，就同意用户登录。 正式操作口令登陆1234$ ssh user@host #user是你想要登陆的用户 host是服务器ip好像也可以用域名，我没试过 The authenticity of host &apos;host (********)&apos; can&apos;t be established. RSA key fingerprint is 98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d. Are you sure you want to continue connecting (yes/no)? 一般来说yes吧。这段话的意思是，无法确认host主机的真实性，只知道它的公钥指纹，问你还想继续连接吗？ 1Are you sure you want to continue connecting (yes/no)? yes 接着yes 1Password: (enter password) 输入密码，对了就可以登陆了。 当接受之后，服务器公钥就会被保存到$HOME/.ssh/known_hosts之中，下次登陆就不会警告了。 但是我用的不是这种方式是下面这种。 公钥登陆可以不用每次输入密码。 所谓”公钥登录”，原理很简单，就是用户将自己的公钥储存在远程主机上。登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录shell，不再要求密码。引用的。。。 必须提供自己的公钥，没有就用下面命令生成 1 $ ssh-keygen 接下来就会一系列提示，一路通过就行，其中一个是是否对私钥设置口令（passphrase），我没用，担心私钥安全可以设置一个。 结束后，$HOME/.ssh/目录下，会新生成两个文件：id_rsa.pub和id_rsa，前面一个公钥，后面是私钥。 1$ ssh-copy-id user@host #user和host之前说过了，这一句就是直接将公钥转送到服务器上 接下来就再用之前 1ssh user@host 这句就行了，如果还不行，去看看那位大佬文章吧。我太菜了。。。]]></content>
  </entry>
  <entry>
    <title><![CDATA[git学习]]></title>
    <url>%2F2019%2F04%2F18%2Fgit%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[说明我不会讲解怎么下载git，这个东西是让我自己复习一下git用的，如果有人需要更加详细的教程的话，建议大家去看廖雪峰的官网，讲的真的挺好的。 开始打开git bash 123mkdir learngit 创建文件夹cd learngit 进入这个文件夹pwd 显示路径 现在只是创建了一个文件夹，现在通过命令让git去管理这个文件夹 12$ git initInitialized empty Git repository in E:/learngit/.git/ 在这个文件夹下有一个.git的文件夹，看不到就是隐藏了，命令ls-ah可以看见 也可以选择其他文件夹让git管理。 文件创建使用git自带vi编译器也可以用其他的 1vi readme.md 按下i键（insert）开始输入,完成输入后ESC退出键，在最下面那一行输入:wq 保存并退出，vi编译器的用法可以自行百度 12git add readme.md 准备增加到仓库git commit -m &quot;wrote a readme.md&quot; 添加到仓库 -m后面接上提交备注 正式操作再次修改readme.md之后使用命令git status查看结果 12345678910111213Asus@LAPTOP-KGR116F7 MINGW64 /e/learngit (master)$ vi readme.mdAsus@LAPTOP-KGR116F7 MINGW64 /e/learngit (master)$ git statusOn branch masterChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: readme.mdno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) ​ 大概意思，readme被修改了，但是没有提交修改，也还没有准备提交修改 git diff 查看修改了什么diff就是different 提交修改和提交新文件一样。 1234567Asus@LAPTOP-KGR116F7 MINGW64 /e/learngit (master)$ git add readme.mdAsus@LAPTOP-KGR116F7 MINGW64 /e/learngit (master)$ git commit -m &quot;add yyy&quot;[master 234e4a0] add yyy 1 file changed, 1 insertion(+), 1 deletion(-) 接着使用git status查看状态 现在可以看到是干净的，没有改动 1234Asus@LAPTOP-KGR116F7 MINGW64 /e/learngit (master)$ git statusOn branch masternothing to commit, working tree clean git log 查看历史版本 git log –pretty=oneline 可以简化 1234Asus@LAPTOP-KGR116F7 MINGW64 /e/learngit (master)$ git log --pretty=oneline234e4a0d6ecb59d5781c6572cf3b478ff8bc9780 (HEAD -&gt; master) add yyy6974bf972901d73fdb4f3239b7218fb282a6421d wrote a readme.md]]></content>
  </entry>
  <entry>
    <title><![CDATA[简单sql注入2]]></title>
    <url>%2F2019%2F04%2F11%2F%E7%AE%80%E5%8D%95sql%E6%B3%A8%E5%85%A52%2F</url>
    <content type="text"><![CDATA[AVG函数 1SELECT AVG(column_name) FROM table_name 12SELECT Customer FROM OrdersWHERE OrderPrice&gt;(SELECT AVG(OrderPrice) FROM Orders) 找到 OrderPrice 值高于 OrderPrice 平均值的客户 COUNT(column_name) 函数返回指定列的值的数目（NULL 不计入）： 1SELECT COUNT(column_name) FROM table_name COUNT(DISTINCT column_name) 函数返回指定列的不同值的数目： 1SELECT COUNT(DISTINCT column_name) FROM table_name 注释：COUNT(DISTINCT) 适用于 ORACLE 和 Microsoft SQL Server，但是无法用于 Microsoft Access。]]></content>
  </entry>
  <entry>
    <title><![CDATA[django模板语言学习]]></title>
    <url>%2F2019%2F04%2F04%2Fdjango%E6%A8%A1%E6%9D%BF%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[django模板语言分类：1.基础语法2.母版和继承3.include方法 基础语法一：基本使用 1&#123;&#123;1111&#125;&#125; name-&gt;变量 for 循环：{ % for i in book_list % } { {i} } { % endfor % } 1&#123;&#123; name &#125;&#125; 3.if判断{ % if 10&gt;5 % } 代码 { % else % } 代码 { % endif % } 4.if...in 判断 { % if name in name_list % } 代码 { % endif % } 字典传参模板语言：{ % for k,v in userinfo.items % } &lt; h2&gt;{ {k} }-{ {v} }&lt; /h2&gt; { % endfor % }效果： 二：filters操作语法：{ {value|filter_name:参数} } 变量加管道符加函数名加参数当前端写了不存在的变量1.{ {xxx|default:&quot;aaa&quot;} }xxx变量存在，输出xxx，不存在会输出默认值aaa 2.{ {value|length} } 返回长度 3.{ {filesize|filesizeformat} } 将为filesize的数字返回为一个文件尺寸 kb mb bytes 4.使用{ {name——list|slice:&quot;1:-1&quot;} }切片5.使用{ {value|date:&quot;Y-m-d H:i:s&quot;} }可以将时间格式化如果不加： 6.{ {value|safe} } 避免前端对内容进行转义 7.{ {value|trucatechars:9} } 字符串字数多于指定的字符数量，就会被截断。截断的字符串以可翻译的省略号结尾参数是截断的字符数 8.代指{ { % with name=name_lsit % } } { {name} } { % endwith % }在作用域内 name也就代指name_list 三 自定义filter方法这个我不会。。。什么时候会了补上 for循环常用的一些参数 四 总结 母版和继承语法把多个页面公用的部分提取出来，放在一个母版里面。其他的页面只需要继承母版就可以了{ % extends &#39;base.html&#39; % }{ # 把自己页面的内容 塞到母版里面相应的位置 # } 这里是每个页面插入到母版页面的位置 { % block page-main % } { % endback % } 使用步骤把公用的html部分提取出来，放到base.html文件中在base.html中，通过定义block，把每个页面不同的部分区分出来在具体的页面，先继承母版然后block名去指定替换母版中的相应的位置 总结{ % extends &#39;base.html&#39; % } base.html要加引号 必须放在子页面的第一行！！可以在base.html中定义很多block，通常我们会额外定义page-css和page-jsview.py相应对的函数返回的是对应的子页面文件，不是base.html include包含{ % include &#39;xiaohei.html&#39; % } 页面包含xaiohei。html页面这个其实比较简单没什么好说的]]></content>
  </entry>
  <entry>
    <title><![CDATA[burp suite intruder爆破方式]]></title>
    <url>%2F2019%2F04%2F01%2Fburp-suite-intruder%E7%88%86%E7%A0%B4%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[前言感觉自己应该改变方式，博客应该尽量简短，实在，有效，每个像以前一样都从基础说起，太浪费时间和篇幅了。这位大佬讲的很好，我也借鉴了很多 intruder(闯入者)四种方式Sniper Battering Ram Pitchfork Cluster Bomb 第一种Sniper简单来说 只有1个字典也就是payload set只能选择1但是可以选择多个要爆破的对象加载顺序：将字典依次填入所有变量中，下图设置了两个变量，所以Position会有两个，先将字典全部填入第一个变量，再第二个变量 第二种Battering ram也只能有一个字典 payload set 只有1也可以选择多个要爆破的对象和上一个区别在于 加载顺序：同时将字典填入所有变量 第三种Pitch forkN个字典 就是payload set可以选择N个爆破对象数量：N个【需要和字段数量相同】加载顺序：字典和变量分别对应，同时填入对应变量中，下图设置了两个变量，变量1依次被填入了user1，user2，user3，变量2依次被填入了pass1，pass2，pass3，user字典和pass字典一一对应 第四种Cluster bombN个字典 payload set 可以选择N个爆破变量 N个加载顺序：字典和变量分别对应，分别填入对应变量中，下图设置了两个变量，变量1依次被填入了user1，user2，user3 变量2首先被填入了pass1，然后是pass2，最后是pass3，user字典和pass字典分别对应，爆破的次数是 user字典数 X pass字段数 最后一种的展示百度实验吧展示sql注入sql语句1’and ascii(substr(select flag from flag),1,1)= 110#选择第四种方式爆破第一个payload第二个payload现在已经爆出来一些值了爆出来的是ascii码 再用burp解码功能解出答案，不能直接爆字段 因为Windows区分大小写而Linux不区分答案：flag{Y0u_@r3_5O_damn90Od}]]></content>
  </entry>
  <entry>
    <title><![CDATA[sql(MySQL为例)]]></title>
    <url>%2F2019%2F03%2F30%2Fsql%E8%AF%AD%E5%8F%A5-MySQL%2F</url>
    <content type="text"><![CDATA[开头感觉自己经常忘记sql语句和一些基本知识，记了又忘，忘了又记，因此写下来，方便以后自己查看。(我好菜啊！！！！)，另外如果大家想要学习sql的话，推荐廖雪峰大神的教程链接 sqlsql简单的解释SQL全称是结构化查询语言(Structured Query Language):是一种特定目的编程语言，用于管理关系数据库管理系统（RDBMS），或在关系流数据管理系统（RDSMS）中进行流处理。 sql注入强调：sql注入的危害很大由于SQL指令在部分高级使用时，语法会依照特定条件来变换，而且若是表格中的字段过多时，许多开发人员都会习惯以字符串组立的方式创建SQL指令，而且又使用系统管理员级的账户连到数据库，因此让黑客有机会利用SQL的组立方式进行攻击，像是在指令中添加部分刺探性或破坏性的指令（例如DROP TABLE、DROP DATABASE或是DELETE * FROM myTable等具破坏性的指令），让数据库的数据或实体服务器被破坏，导致服务中断或是系统瘫痪等后果，或是以逻辑的漏洞，在密码栏写入特殊字符串(例如’ or ‘1’=’1)，让该字符串形成的逻辑判断永远为真，或直接获取非查询条件的数据，而不需要知道密码，以达成非法登录系统的目的，此种攻击手法称为SQL注入（SQL injection）。 sql的种类sql数据库通常分为层次式数据库、网络式数据库和关系式数据库三种。而不同的数据库是按不同的数据结构来联系和组织的。除此之外，现如今用的比较多的还有非关系型数据库(NoSQL),注意是not only sql 不是 no,sql。也就是说NoSQL更多是对于关系型数据库的补充而不是竞争。NoSql数据库在特定的场景下可以发挥出难以想象的高效率和高性能。但是非关系型数据库缺陷是没有关系型数据库那么稳定安全。我在这里主要说的是关系型数据库。关系数据库，是建立在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据。现实世界中的各种实体以及实体之间的各种联系均用关系模型来表示。关系模型是由埃德加·科德于1970年首先提出的，并配合“科德十二定律”。现如今虽然对此模型有一些批评意见，但它还是数据存储的传统标准。标准数据查询语言SQL就是一种基于关系数据库的语言，这种语言执行对关系数据库中数据的检索和操作。 关系模型由关系数据结构、关系操作集合、关系完整性约束三部分组成。简单说，关系型数据库是由多张能互相联接的二维行列表格组成的数据库。我自己的理解就是靠一张张的表格形成数据之间的联系。 所有sql数据库的大名鼎鼎的四大特性解释的很好的链接链接 1.原子性（Atomicity）原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。我曾经看到的一个很好的解释原子性的说法：在很久以前，大家认为原子是最小的东西，不可分割，不可能存在半个原子，因此，原子性就是数据库事务要么全部成功，要么全部失败，不能只做一半。 2.一致性（Consistency）一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。 3.隔离性（Isolation） 隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。 即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。 4.持久性（Durability） 持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。 例如我们在使用JDBC操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务以及正确提交，即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误。 sql 数据库及表的创建和删除mysql 连接mysql -u 账号 -p(我的是root)，接下来输入密码就好show databases;显示数据库create database 库名;创建数据库drop database 库名;删除数据库 mysql 建表操作建表太多了，我就不一一展示。 sql语句操作增]]></content>
  </entry>
  <entry>
    <title><![CDATA[爬虫学习一]]></title>
    <url>%2F2019%2F03%2F24%2F%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0%E4%B8%80%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[dvwa之xxs(跨站脚本攻击)]]></title>
    <url>%2F2019%2F03%2F23%2Fdvwa%E4%B9%8Bxxs-%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB%2F</url>
    <content type="text"><![CDATA[xss的介绍xss的定义跨站脚本（英语：Cross-site scripting，通常简称为：XSS）是一种网站应用程序的安全漏洞攻击，是代码注入的一种。它允许恶意用户将代码注入到网页上，其他用户在观看网页时就会受到影响。这类攻击通常包含了HTML以及用户端脚本语言。XSS攻击通常指的是通过利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。这些恶意网页程序通常是JavaScript，但实际上也可以包括Java，VBScript，ActiveX，Flash或者甚至是普通的HTML。攻击成功后，攻击者可能得到更高的权限（如执行一些操作）、私密网页内容、会话和cookie等各种内容。(维基百科) xss的意义 xss的危害 xss攻击分类反射型xss储存型xssDOM型xss xss的一些攻击代码 reflect xss(反射型xss)low级别首先可以看到没有对提交的信息进行过滤，直接插入代码中，连&gt;也没有进行处理，想到如果输入js代码是不是也会直接插入 试试输入 &lt; s cript&gt;alert(‘xss’)&lt;/ s cript&gt;其实是没有空格的。。。转义的原因。可以看见发生弹窗 xss源代码代码分析：没有过滤，直接将name连接到页面上的html语言内 Medium级别同样先&lt; s cript&gt;alert(‘xss’)&lt;/ s cript&gt;（注意不要用空格）试试，发现不行，并且没有原样插入html代码想到过滤了，并且alert函数没被过滤，想到可能只对script过滤了？因为html不区分大小写，试试用大写的script成功弹窗！源代码代码分析：将&lt; script&gt;用str_place函数删除除了大写的方式还可以通过script大小写混合以及&lt; sc&lt; script&gt;ript&gt;alert(/xss/)&lt; /script&gt;双写绕过 高级别代码分析：htmlspecialchars函数将所有html把预定义的字符&amp;、”、 ’、&lt;、&gt;转换为 HTML 实体，防止浏览器将其作为HTML元素。绕不过。。。 stored xss(存储型xss)区别存储型和反射型区别在于存储型xss是一直存在的，比如评论之类的地方，所有人都能看见，危害很大 low级别同样先是直接&lt; s cript&gt;alert(/xss/)&lt;/ s cript&gt;成功，然后刷新页面试试，可以发现反射型不同，存储型再次弹窗。name字段同样可以，前端限制了字数，直接F12改前端就好源代码代码分析：trim(string,charlist)函数移除字符串两侧的空白字符或其他预定义字符，预定义字符包括、\t、\n、\x0B、\r以及空格，可选参数charlist支持添加额外需要删除的字符。mysql_real_escape_string(string,connection)函数会对字符串中的特殊符号（\x00，\n，\r，\，‘，“，\x1a）进行转义。stripslashes(string)函数删除字符串中的反斜杠。可以看到，对输入并没有做XSS方面的过滤与检查，且存储在数据库中，因此这里存在明显的存储型XSS漏洞。源代码同样用script大写就可以绕过代码分析：strip_tags() 函数剥去字符串中的 HTML、XML 以及 PHP 的标签，但允许使用&lt; b&gt;标签。addslashes() 函数返回在预定义字符（单引号、双引号、反斜杠、NULL）之前添加反斜杠的字符串。可以看到，由于对message参数使用了htmlspecialchars函数进行编码，因此无法再通过message参数注入XSS代码，但是对于name参数，只是简单过滤了&lt; script&gt;字符串，仍然存在存储型的XSS。同样用name字段script大写就可以绕过，记得前端改字数限制就行以及双写和大小写混淆都可以 high级别简单来说，name和message都是严格验证，绕不过。]]></content>
  </entry>
  <entry>
    <title><![CDATA[dvwa之Command csrf(跨站请求伪造)]]></title>
    <url>%2F2019%2F03%2F22%2Fdvwa%E4%B9%8BCommand-csrf-%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0%2F</url>
    <content type="text"><![CDATA[csrf的介绍 csrf的定义跨站请求伪造（英语：Cross-site request forgery），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。[1] 跟跨网站脚本（XSS）相比，XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。(维基百科定义) csrf的防御检查Referer字段HTTP头中有一个Referer字段，这个字段用以标明请求来源于哪个地址。在处理敏感数据请求时，通常来说，Referer字段应和请求的地址位于同一域名下。以上文银行操作为例，Referer字段地址通常应该是转账按钮所在的网页地址，应该也位于 www.examplebank.com之下。而如果是CSRF攻击传来的请求，Referer字段会是包含恶意网址的地址，不会位于www.examplebank.com之下，这时候服务器就能识别出恶意的访问。 这种办法简单易行，工作量低，仅需要在关键访问处增加一步校验。但这种办法也有其局限性，因其完全依赖浏览器发送正确的Referer字段。虽然http协议对此字段的内容有明确的规定，但并无法保证来访的浏览器的具体实现，亦无法保证浏览器没有安全漏洞影响到此字段。并且也存在攻击者攻击某些浏览器，篡改其Referer字段的可能。 添加校验token由于CSRF的本质在于攻击者欺骗用户去访问自己设置的地址，所以如果要求在访问敏感数据请求时，要求用户浏览器提供不保存在cookie中，并且攻击者无法伪造的数据作为校验，那么攻击者就无法再运行CSRF攻击。这种数据通常是窗体中的一个数据项。服务器将其生成并附加在窗体中，其内容是一个伪随机数。当客户端通过窗体提交请求时，这个伪随机数也一并提交上去以供校验。正常的访问时，客户端浏览器能够正确得到并传回这个伪随机数，而通过CSRF传来的欺骗性攻击中，攻击者无从事先得知这个伪随机数的值，服务端就会因为校验token的值为空或者错误，拒绝这个可疑请求。 dvwa之csrf通过csrf来演示 low级别思路：首先看到页面后发现直接输入新密码就可以更改，不用之前的密码，也许可以scrf，使用burp suite抓包抓包后，使用burp的自动生成csrf页面功能对应新密码和确认新密码，改成两个一样的密码，我都改成111，然后打开这个html页面打开之后，就是点击submit，因为用户本身有session，不需要验证，进入页面，就直接将表单提交到了更改密码的网页。然后，就没有然后了，你号就没了。代码分析：可以看到，服务器收到修改密码的请求后，会检查参数password_new与password_conf是否相同，如果相同，就会修改密码，并没有任何的防CSRF机制（当然服务器对请求的发送者是做了身份验证的，是检查的cookie，只是这里的代码没有体现= =）。 medium级别算了，直接看代码吧。。。代码分析：int eregi(string pattern, string string)检查string中是否含有pattern（不区分大小写），如果有返回True，反之False。可以看到，Medium级别的代码检查了保留变量 HTTP_REFERER（http包头的Referer参数的值，表示来源地址）中是否包含SERVER_NAME（http包头的Host参数，及要访问的主机名，这里是192.168.177.133），希望通过这种机制抵御CSRF攻击。检查是否是本机发送的请求我们可以也通过burp将refer值更改成]]></content>
  </entry>
  <entry>
    <title><![CDATA[dvwa之Command Execution(命令执行)]]></title>
    <url>%2F2019%2F03%2F19%2Fdvwa%2F</url>
    <content type="text"><![CDATA[命令执行的简单意义命令注入（Command Injection），是指在某些需要输入数据的位置，还构造了恶意的代码破坏了原先的语句结构。而系统缺少有效的过滤，最终达到破坏数据、信息泄露甚至掌控电脑的目的。许多内容管理系统CMS存在命令注入漏洞。 注入命令思路注：命令执行的权限取决于存在漏洞的应用程序(网站的话也就是web中间件的权限) 常见的注入系统命令功能 ping 测试网站连通性-本身是一般是网站用来给用户提供ip地址的 netstat 查看网络端口及连接状态 netstat -pantu| grep :80 查看端口的占用情况 net user 查看系统账号 net localgroup 查看系统用户组 dir 当前目录下的文件和子目录信息 req 注册表 tasklist 当前运行的进程信息 查看ip ipconfig-windows ifconfig-Linux whoami 当前用户 cat 查看文件 ls 列出当前目录下的文件夹 useradd 添加用户 userdel 删除用户 systeminfo 查看计算机综合信息 “|”：前面命令输出结果作为后面命令的输入内容； “||”：前面命令执行失败的时候才执行后面的命令； “&amp;”：前面命令执行后接着执行后面的命令； “&amp;&amp;”：前面命令执行成功了才执行后面的命令。在我自己电脑进行的模拟实验ping 127.0.0.1 &amp; net user(忘记加ping了，不重要。。。，重要的是现在没有test用户) ping 127.0.0.1 &amp; net user test 123 /add (执行后可以看见有了test用户密码123) ping 127.0.0.1 &amp; net localgroup adminstrators test /add (添加test用户到管理员组)ping 127.0.0.1 &amp; net localgroup adminstrators (查看管理员组，可以看到已经添加了) low级别源代码isset() 判断提交方法target 获得ip变量stristr() 判断操作系统问题：直接拼接ip变量到系统命令上]]></content>
  </entry>
  <entry>
    <title><![CDATA[hexo blog 心路历程]]></title>
    <url>%2F2019%2F01%2F15%2Fhexo-blog-%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[first 说明我已经说过了我是个菜鸡，只是当时搭建博客时还是痛苦了一下，因此决定写下来以梳理一下自己的收获，如何我有不足或错误的地方，希望大家能指出。 ps:如果在某些地方出了错，请先去之前附上链接的那篇文章看看，如果那篇文章中没有提出你的问题，首先看看你的出错信息，到底是warning还是error，由于git最开始只能在Linux和UNIX上使用，之后可以在windows上使用，因此由于操作系统不同，所以可能会出现在一些地方warning，但是这不影响接下来的使用，如果是error，那就只能看看错误信息，然后度娘吧，我太菜了。。。在此附上我觉得写的很好的关于hexo+github搭建博客的文章的链接，我当时也是按照这篇文章操作的，非常感谢文章作者，在此附上链接 hexo+github博客搭建之路 附上另外一位大佬的教程 second 开始安装 Node.js和Git（搭建环境）如果你是和我一样的小白我相信你一定不知道这两个是什么鬼东西，而如果你是大佬就不用看我写的了。。。 Node.js：Node.js 是一个让 JavaScript 运行在服务端的开发平台 是JavaScript工具（垃圾解释）Git：git就比较好解释了 分布式版本控制系统 什么？你想知道更多关于git的？文章链接 廖雪峰老师讲的是真的好大家可以多看看，我大概看了一下，就只知道git很牛逼。。。Node.js下载链接git下载链接git的官网下载会很慢 总的来说这两个意义是搭建环境，实在不懂也没关系。安装完成后，在开始菜单找到git bash 进入输入：git config –global user.name “你的github用户名”git congig –global user.email “你的github留下的邮箱”config 配置 –global 全局声明 记住都不能用中文字符！ third 安装hexo这个比较简单还是在git bash 命令行里 直接输入：npm install -g hexo-cli 配置github来到github登录（注册) 这里的仓库名称是一定是你注册的名字 比如我是wcqy-ye 那我就是 wcqy-ye.github.io (我就是曾经搞错过，最后就出错了)生成添加密钥在git终端输入ssh-keygen -t rsa -C “Github的注册邮箱地址”一路确定过来就好生成完成后会有两个文件 id_rsa和id_rsa.pub一个是ssh公钥一个是ssh私钥找不到路径的可以看看我的，不一定一样但是应该都在c盘，用编辑器打开 全部复制内容,进入设置公钥title你随意 复制的内容到key里然后点击add ssh key 本地环境对了 ，github仓库也有了 现在就是在本地开始搭建仓库了初始化博客在电脑F盘(其实随便)新建文件夹(这个就是之后的博客相关文件的文件夹了，起个好名字吧！，随便然并卵。。。)进入这个文件夹，然后右键，打开git bash输入 hexo init blog (初始化博客，也就是说成功后，在本地博客就已经搭建好了)进入到blog文件夹下，比喻（不进去是打不开本地博客的，你在窗户外叫窗户内的人他是听不见的）输入 hexo s，可以看到已经打开了，本地4000端口 浏览器 输入localhost:4000 看看是不是这样本地博客雏形就有了 本地博客配置在blog目录下，用sublime/notepad++等文本编辑器打开_config.yml文件，修改参数信息。我知道肯定有人不知道什么是blog目录我当时就不知道。。。看看吧 语言和地区都是有规范的，网上能找到。。。 接下来部署到github的远程仓库还是在刚刚那个文件里大概是在最后的位置其中repo项是之前Github上创建好的仓库的地址，可以通过如下图所示的方式得到： 发表文章 git终端输入 hexo new “文章名字” 记住一定要在这个目录下输入不然不行 根据路径找到文章，使用markdown语言编辑 接下来在刚刚那个目录(blog目录)输入三个命令： 打开 http://localhost:4000/ 预览本地的样子 最后一步发布到远程执行 hexo deploy正常情况下，第一次会跳出Github登录，直接登录；如果没有问题，在浏览器输入博客地址：然后就可以看到已经有内容了。（有可能稍有延迟） 所以这就是大功告成了！！！一些常用命令和基础hexo 有很多的主题大家可以自己去多找一下搭建博客的方式也远不止hexo+github但我太菜了。。。。 现在来介绍常用的Hexo 命令npm install hexo -g #安装Hexonpm update hexo -g #升级hexo init #初始化博客 命令简写hexo n “我的博客” == hexo new “我的博客” #新建文章hexo g == hexo generate #生成hexo s == hexo server #启动服务预览hexo d == hexo deploy #部署 hexo server #Hexo会监视文件变动并自动更新，无须重启服务器hexo server -s #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IPhexo clean #清除缓存，若是网页正常情况下可以忽略这条命令 刚刚的三个命令依次是新建一篇博客文章、生成网页、在本地预览的操作。 blog根目录里的_config.yml文件称为站点配置文件进入根目录里的themes文件夹，里面也有个_config.yml文件，这个称为主题配置文件]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F01%2F10%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
